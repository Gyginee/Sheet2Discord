"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const events_1 = require("events");
const backtracker_1 = require("backtracker");
const selfReloadError = "Do not attempt to re-require Heatsync. If you REALLY want to, do it yourself with require.cache and deal with possibly ticking timers and event listeners, but don't complain if something breaks :(";
function isObject(item) {
    var _a;
    if (typeof item !== "object" || item === null || Array.isArray(item))
        return false;
    return (((_a = item.constructor) === null || _a === void 0 ? void 0 : _a.name) === "Object");
}
class Sync {
    constructor(options) {
        var _a, _b;
        /**
         * An EventEmitter which emits absolute reloaded file paths.
         */
        this.events = new events_1.EventEmitter();
        /**
         * A Map keyed by absolute file paths which details listeners added to a target.
         */
        this._listeners = new Map();
        /**
         * A Map keyed by absolute file paths which holds references to imports.
         */
        this._references = new Map();
        /**
         * A Map keyed by absolute file paths which are being watched by heatsync.
         */
        this._watchers = new Map();
        this._options = {};
        if ((options === null || options === void 0 ? void 0 : options.watchFS) === undefined)
            this._options.watchFS = true;
        else
            this._options.watchFS = (_a = options.watchFS) !== null && _a !== void 0 ? _a : false;
        if ((options === null || options === void 0 ? void 0 : options.persistentWatchers) === undefined)
            this._options.persistentWatchers = true;
        else
            this._options.persistentWatchers = (_b = options.persistentWatchers) !== null && _b !== void 0 ? _b : false;
    }
    require(id, _from) {
        let from;
        from = _from ? _from : backtracker_1.BackTracker.stack.first().dir;
        if (Array.isArray(id))
            return id.map(item => this.require(item, from));
        const directory = !path_1.default.isAbsolute(id) ? require.resolve(path_1.default.join(from, id)) : require.resolve(id);
        if (directory === __filename)
            throw new Error(selfReloadError);
        const value = require(directory);
        if (!isObject(value))
            throw new Error(`${directory} does not export an Object and as such, changes made to the file cannot be reflected as the value would be immutable. Importing through HeatSync isn't supported and may be erraneous`);
        const oldObject = this._references.get(directory);
        if (!oldObject) {
            this._references.set(directory, value);
            if (this._options.watchFS) {
                let timer = null;
                this._watchers.set(directory, fs_1.default.watch(directory, { persistent: this._options.persistentWatchers }, () => {
                    if (timer) {
                        clearTimeout(timer);
                        timer = null;
                    }
                    timer = setTimeout(() => {
                        delete require.cache[directory];
                        try {
                            this.require(directory);
                        }
                        catch (e) {
                            return this.events.emit("error", e);
                        }
                        this.events.emit(directory);
                        this.events.emit("any", directory);
                        const listeners = this._listeners.get(directory);
                        if (!listeners)
                            return;
                        for (const [target, event, func] of listeners) {
                            target.removeListener(event, func);
                        }
                    }, 1000).unref(); // Only emit and re-require once all changes have finished
                }));
            }
        }
        else {
            for (const key of Object.keys(oldObject)) {
                if (!value[key])
                    delete oldObject[key];
            }
            Object.assign(oldObject, value);
        }
        const ref = this._references.get(directory);
        if (!ref)
            return value;
        else
            return ref;
    }
    import(_id, _from) {
        throw new Error("The CJS version of this module does not support the import statement");
    }
    addTemporaryListener(target, event, callback, method = "on") {
        const first = backtracker_1.BackTracker.stack.first();
        const absolute = path_1.default.normalize(`${first.dir}/${first.filename}`);
        if (!this._listeners.get(absolute))
            this._listeners.set(absolute, []);
        this._listeners.get(absolute).push([target, event, callback]);
        setImmediate(() => target[method](event, callback));
        return target;
    }
    resync(id, _from) {
        let from;
        if (typeof id === "string" && !id.startsWith("."))
            from = require.resolve(id);
        else
            from = _from ? _from : backtracker_1.BackTracker.stack.first().dir;
        if (Array.isArray(id))
            return id.map(item => this.resync(item, from));
        const directory = !path_1.default.isAbsolute(id) ? require.resolve(path_1.default.join(from, id)) : require.resolve(id);
        if (directory === __filename)
            throw new Error(selfReloadError);
        delete require.cache[directory];
        return this.require(directory);
    }
}
module.exports = Sync;
//# sourceMappingURL=index.js.map